{
  "hash": "0b7cd5bf40c731e217392b6b6b68fb21",
  "result": {
    "engine": "knitr",
    "markdown": "# Introduction to R {#sec-Rintro}\n\nThis Chapter serves two purposes. First, it introduces you to R.  Second, it introduces functions for conducting an ordinary least squares (OLS) regression on a data set supplied within R.\n\nThe nice thing about Quarto (similar to .RMD) files, is that you can integrate code within text files. The text files can be rendered into HTML, PDF, or Word documents (among others). These documents are therefore like a 'laboratory' notebook that allow you to show your coding work, visual outputs, and contextualizing your work with text using a visually aesthetic framework.\n\nR is a free and open-source programming language, with many functions supplied by the \"base\" code. However, many other functions require loading 3rd party packages. Be aware that none of the functions in these other packages are guaranteed to work in a certain way (although many are very well maintained and validated by large user bases). You'll need to do your own research to make sure which functions can be trusted, and sometimes you'll need to devise your own strategies to test the functions to make sure they work as they claim to.\n\n## Load a package\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The library() function loads R packages that are not supplied in the \"base\" software\n# You need to install a package once before loading\n# install.packages('dplyr')\n# Load the 'dplyr' package which has many convenient data manipulation functions\nlibrary(dplyr) \n```\n:::\n\n\n## Load a data set\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R has many built-in data sets for educational purposes.\n# The data() function will show all of these, with descriptions\ndata() # Do this on your own.\n```\n:::\n\n\n## Manipulate and visualize the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the 'iris' data set, which contains lengths and widths of flower petals\n# We choose this, because these lengths and widths are often linearly associated\ndata(iris)\n\nis.data.frame(iris) # Validate as data frame object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.vector(iris) # Not a vector object\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(iris) # Show general object characteristics\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(iris) # Similar to str() but more detailed/relevant\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n```\n\n\n:::\n\n```{.r .cell-code}\n# glimpse() is a function within the dplyr package. \n# We can call the function like this, because dplyr was loaded already\n# Alternatively we can use the following syntax to call non-base functions\ndplyr::glimpse(iris)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.…\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.…\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.…\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.…\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s…\n```\n\n\n:::\n\n```{.r .cell-code}\n# This way, you are less prone to errors, especially if \n# functions in different packages are named the same or similarly (masking)\n```\n:::\n\n\nFrom the `glimpse()` function we see that there are five columns within the `iris` data frame, and there are 150 total data points (rows). We also see that four columns are numeric doubles, while one (Species) is a factor.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset column vectors from the data frame using the '$' symbol\nmean(iris$Petal.Length)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.758\n```\n\n\n:::\n\n```{.r .cell-code}\n# R can do 'vectorized' functions \niris$Petal.Width * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 0.4 0.4 0.4 0.4 0.4 0.8 0.6 0.4 0.4 0.2 0.4 0.4 0.2 0.2 0.4 0.8 0.8 0.6\n [19] 0.6 0.6 0.4 0.8 0.4 1.0 0.4 0.4 0.8 0.4 0.4 0.4 0.4 0.8 0.2 0.4 0.4 0.4\n [37] 0.4 0.2 0.4 0.4 0.6 0.6 0.4 1.2 0.8 0.6 0.4 0.4 0.4 0.4 2.8 3.0 3.0 2.6\n [55] 3.0 2.6 3.2 2.0 2.6 2.8 2.0 3.0 2.0 2.8 2.6 2.8 3.0 2.0 3.0 2.2 3.6 2.6\n [73] 3.0 2.4 2.6 2.8 2.8 3.4 3.0 2.0 2.2 2.0 2.4 3.2 3.0 3.2 3.0 2.6 2.6 2.6\n [91] 2.4 2.8 2.4 2.0 2.6 2.4 2.6 2.6 2.2 2.6 5.0 3.8 4.2 3.6 4.4 4.2 3.4 3.6\n[109] 3.6 5.0 4.0 3.8 4.2 4.0 4.8 4.6 3.6 4.4 4.6 3.0 4.6 4.0 4.0 3.6 4.2 3.6\n[127] 3.6 3.6 4.2 3.2 3.8 4.0 4.4 3.0 2.8 4.6 4.8 3.6 3.6 4.2 4.8 4.6 3.8 4.6\n[145] 5.0 4.6 3.8 4.0 4.6 3.6\n```\n\n\n:::\n\n```{.r .cell-code}\n# Check if factor\nis.factor(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.character(iris$Species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nLet's make some exploratory visualizations.\n\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code}\n# Histogram\nhist(iris$Petal.Length)\n```\n\n::: {.cell-output-display}\n![](Rintro_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nhist(iris$Petal.Width)\n```\n\n::: {.cell-output-display}\n![](Rintro_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Explore association between random variables\n# formula method: y ~ x \n# Read the above like: \n# y-variable 'modeled by' x-variable, or\n# y-variable 'as a function of' x-variable\nplot(iris$Petal.Width ~ iris$Petal.Length,\n     xlab = \"Length\",\n     ylab = \"Width\",\n     pch = 19) #pch = plot character\n```\n\n::: {.cell-output-display}\n![](Rintro_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n## Is there a linear association?\n\nThe goal of regression is to determine the functional association between random variables. With linear regression the specific goal is to test whether there is a linear relationship between a response variable (*y*) and one or more covariates (*x*). The form of the functional relationship is: \n$$y_i = \\beta_0 + \\beta_1 x_i + \\epsilon_i ,$$\nwhere $y_i$ is the $i$-th data point, $\\beta_0$ is the intercept, $\\beta_1$ is the slope, and $x$ is the single covariate in the model. In matrix form we have: \n$$\\bf{y} = \\bf{X} \\bf{B} + \\boldsymbol\\epsilon$$ \nFor hypothesis testing, we are testing the null hypothesis that the slope of the relationship between $x$ and $y$ is zero (i.e., no detectable linear relationship, $\\beta_1 = 0$).\n\nWe can conduct linear regression in R using the `lm()` function, where 'lm' stands for 'linear model'. This function specifically estimates the model parameter (slope, intercept, and residual variance), using the ordinary least squares approach, which we will soon learn in lecture.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_model = lm(formula = Petal.Width ~ Petal.Length,\n              data = iris)\n```\n:::\n\n\nThe line above stores the output of the linear model in the `my_model` object. We can then manipulate the `my_model` object and apply various functions to help us understand the outcome of the linear regression analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(my_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 12\n $ coefficients : Named num [1:2] -0.363 0.416\n  ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"Petal.Length\"\n $ residuals    : Named num [1:150] -0.019 -0.019 0.0226 -0.0606 -0.019 ...\n  ..- attr(*, \"names\")= chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n $ effects      : Named num [1:150] -14.6888 8.9588 0.0257 -0.0576 -0.0159 ...\n  ..- attr(*, \"names\")= chr [1:150] \"(Intercept)\" \"Petal.Length\" \"\" \"\" ...\n $ rank         : int 2\n $ fitted.values: Named num [1:150] 0.219 0.219 0.177 0.261 0.219 ...\n  ..- attr(*, \"names\")= chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n $ assign       : int [1:2] 0 1\n $ qr           :List of 5\n  ..$ qr   : num [1:150, 1:2] -12.2474 0.0816 0.0816 0.0816 0.0816 ...\n  .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. ..$ : chr [1:150] \"1\" \"2\" \"3\" \"4\" ...\n  .. .. ..$ : chr [1:2] \"(Intercept)\" \"Petal.Length\"\n  .. ..- attr(*, \"assign\")= int [1:2] 0 1\n  ..$ qraux: num [1:2] 1.08 1.1\n  ..$ pivot: int [1:2] 1 2\n  ..$ tol  : num 1e-07\n  ..$ rank : int 2\n  ..- attr(*, \"class\")= chr \"qr\"\n $ df.residual  : int 148\n $ xlevels      : Named list()\n $ call         : language lm(formula = Petal.Width ~ Petal.Length, data = iris)\n $ terms        :Classes 'terms', 'formula'  language Petal.Width ~ Petal.Length\n  .. ..- attr(*, \"variables\")= language list(Petal.Width, Petal.Length)\n  .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. ..$ : chr [1:2] \"Petal.Width\" \"Petal.Length\"\n  .. .. .. ..$ : chr \"Petal.Length\"\n  .. ..- attr(*, \"term.labels\")= chr \"Petal.Length\"\n  .. ..- attr(*, \"order\")= int 1\n  .. ..- attr(*, \"intercept\")= int 1\n  .. ..- attr(*, \"response\")= int 1\n  .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n  .. ..- attr(*, \"predvars\")= language list(Petal.Width, Petal.Length)\n  .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. ..- attr(*, \"names\")= chr [1:2] \"Petal.Width\" \"Petal.Length\"\n $ model        :'data.frame':\t150 obs. of  2 variables:\n  ..$ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n  ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n  ..- attr(*, \"terms\")=Classes 'terms', 'formula'  language Petal.Width ~ Petal.Length\n  .. .. ..- attr(*, \"variables\")= language list(Petal.Width, Petal.Length)\n  .. .. ..- attr(*, \"factors\")= int [1:2, 1] 0 1\n  .. .. .. ..- attr(*, \"dimnames\")=List of 2\n  .. .. .. .. ..$ : chr [1:2] \"Petal.Width\" \"Petal.Length\"\n  .. .. .. .. ..$ : chr \"Petal.Length\"\n  .. .. ..- attr(*, \"term.labels\")= chr \"Petal.Length\"\n  .. .. ..- attr(*, \"order\")= int 1\n  .. .. ..- attr(*, \"intercept\")= int 1\n  .. .. ..- attr(*, \"response\")= int 1\n  .. .. ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n  .. .. ..- attr(*, \"predvars\")= language list(Petal.Width, Petal.Length)\n  .. .. ..- attr(*, \"dataClasses\")= Named chr [1:2] \"numeric\" \"numeric\"\n  .. .. .. ..- attr(*, \"names\")= chr [1:2] \"Petal.Width\" \"Petal.Length\"\n - attr(*, \"class\")= chr \"lm\"\n```\n\n\n:::\n:::\n\n\nObviously, the output of the analysis is a complicated data structure with many elements. There are, however, some convenient functions to summarize these outputs for us.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(my_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = Petal.Width ~ Petal.Length, data = iris)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.56515 -0.12358 -0.01898  0.13288  0.64272 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  -0.363076   0.039762  -9.131  4.7e-16 ***\nPetal.Length  0.415755   0.009582  43.387  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.2065 on 148 degrees of freedom\nMultiple R-squared:  0.9271,\tAdjusted R-squared:  0.9266 \nF-statistic:  1882 on 1 and 148 DF,  p-value: < 2.2e-16\n```\n\n\n:::\n:::\n\n\nAbove is the main outcome that we care about. The `summary()` function tells us the parameter estimates (with estimates of parameter uncertainty). It also conducts null-hypothesis testing, providing p-values, and shows the goodness of model fit, using R-squared.\n\n::: {.callout-tip}\n\nThe goal of the first part of this course is to understand in sufficient detail how this analysis is conducted, so that we can interpret the results from a well-informed standpoint.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(iris$Petal.Width ~ iris$Petal.Length,\n     xlab = \"Length\",\n     ylab = \"Width\",\n     pch = 19)\n# Add the estimated linear relationship\nabline(reg = my_model)\n```\n\n::: {.cell-output-display}\n![Data with fitted linear relationship.](Rintro_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Rintro_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}