{"title":"Maximum Likelihood","markdown":{"headingText":"Maximum Likelihood","headingAttr":{"id":"sec-max-lik","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n## Lecture material\n\nPlease download and print the lecture materials from [Bblearn](https://bblearn.nau.edu/){target=\"_blank\"}. After lectures, the recordings will appear in the Bblearn Collaborate Ultra section.\n\n## Generate some data {#sec-data}\n\nFirst, let's generate some data for the case of a simple linear regression.\n\n```{r}\n### PARAMS\nbeta0 = 1.5\nbeta1 = 0.5\nsigma = 0.4\nn = 30\n\n### GENERATE DATA\nset.seed(5)\nx = runif(n, -1.5, 1.5)\nexp_y = beta0 + beta1*x\ny = exp_y + rnorm(n, mean=0, sd=sigma)\n\n# Create a data frame \nmy_df = data.frame(y = y, x = x)\n\nplot(my_df$y ~ my_df$x, pch = 19,\n     xlab = \"x\", ylab = \"y\")\n```\n\n## Calculate a likelihood\n\nRemember that, for simple linear regression, the likelihood of a single data point is as follows:\n$$y_i \\sim N(\\beta_0 + \\beta_1 x_i, \\sigma^2)$$\n$$P(y_i | X_i B, \\sigma^2) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\text{e}^{-\\frac{1}{2}\\frac{(y_i - X_i B)^2}{\\sigma^2}}$$\n\nThen, the full likelihood of the data set $Y$ is computed as:\n\n$$ P(Y | X B, \\sigma^2) = \\prod^n_{i=1} P(y_i | X_i B, \\sigma^2)$$\nOr, on the natural logarithmic scale:\n$$ ln\\left(P(Y | X B, \\sigma^2)\\right) = \\sum^n_{i=1} ln\\left(P(y_i | X_i B, \\sigma^2)\\right)$$\n\n```{r}\n# How to calculate the likelihood of a single data point:\ndnorm(y[1], \n      mean = beta0 + beta1*x[1],\n      sd = sigma,\n      log = FALSE)\n\n# Calculate the full likelihood of the data, using the product\n## Vectorized:\nLH_notlog= \nprod(\n    dnorm(y, \n          mean = beta0 + beta1*x,\n          sd = sigma,\n          log = FALSE)\n)\n\n# Log-likelihood, vectorized\nLH_log = \nsum(\n    dnorm(y, \n          mean = beta0 + beta1*x,\n          sd = sigma,\n          log = TRUE)\n)\n\n# Make sure the output makes sense\nLH_notlog\n# Indeed the log-likelihood is the log of the \n# likelihood on the raw probability scale.\nLH_log; log(LH_notlog)\n```\n\n## Using `optim()` to minimize the negative log-likelihood\n\nAs we discussed in lecture, it is more computationally convenient to minimize functions, rather than to maximize. Therefore, to conduct linear regression analysis with maximum likelihood methods, we will find the values of $\\hat{B}$ that minimize the negative log-likelihood of the data: $-ln\\left(P(Y | X B, \\sigma^2)\\right)$.\n\n### Function to calculate the negative log-likelihood\n\nFirst, we need to construct a function that calculates the negative log-likelihood and that specifies the parameters of the model that eventually need to be estimated by the `optim()` function.\n\n```{r}\n### NEG LOG-LIK MINIMIZATION\nneg_log_lik = function(p, data_df){\n    beta0=p[1]\n    beta1=p[2]\n    sigma=p[3]\n    \n    mu = beta0 + beta1*data_df$x\n    \n    nll = -sum(dnorm(data_df$y, mean=mu, sd=sigma, log = TRUE))\n    return(nll)\n}\n```\nHere you can see the inputs to the function: `p` is a vector of parameters to be estimated (i.e., optimized), and `data_df` is a `data.frame` that holds the values of outcome variable $y$ and associated input variables, in this case, just one $x$. \n\nThen, we can use the `optim()` function, which implements a gradient descent algorithm to estimate the values of the parameters that minimize the provided function, `neg_log_lik()`. We will learn more about gradient descent later, because this is a very important method used widely across machine learning and neural networks. \n\n```{r}\nm_nll = \n    optim(\n        par = c(0.1,0,0.1),\n        fn = neg_log_lik,\n        data_df = my_df,\n        method = \"L-BFGS-B\",\n        lower=c(-5,-5,0.001),\n        upper=c(5,5,5),\n        hessian = TRUE\n    )\npar_tab_nll = rbind(m_nll$par)\ncolnames(par_tab_nll) = c(\"int\", \"slope\", \"sigma\")\npar_tab_nll\n```\nNote the `optim()` options. `par` specifies the initial guesses of the three parameters, whereas `lower` and `upper` specify the bounds across which to search for the best values of the parameters. With `hessian = TRUE` we are asking the function to output an estimate of the Hessian matrix of the function, which helps us to estimate the standard errors of the parameter estimates (see [Footnotes @sec-hessian]). The `method` specifies the algorithm used to minimize the function, which in this case is a modified quasi-Newton method, `L-BFGS-B`, which is a type of gradient descent algorithm, to be discussed later. \n\nWe can see that the function outputs three point-estimates, which are $\\hat{B}$ (i.e., slope and intercept), as well as the residual standard deviation, $\\hat{\\sigma}$.\n\n### Compare `optim()` results to the OLS output\n```{r}\n### COMPARE TO LM()\nm_ols = lm(y ~ 1 + x, data = my_df)\nm_ols_summary = summary(m_ols)\nm_ols_summary # Notice p-value\n\npar_tab_ols = c(coef(m_ols), m_ols_summary$sigma)\nnames(par_tab_ols) = c(\"int\", \"slope\", \"sigma\")\npar_tab_ols; par_tab_nll\n\nplot(my_df$y ~ my_df$x, pch = 19,\n     xlab = \"x\", ylab = \"y\")\n# Line from OLS\nabline(coef = coef(m_ols), col = \"black\", lwd = 2)\n# Line from MaxLikelihood\nabline(coef = m_nll$par[1:2], col = \"red\", lty = 2, lwd = 2)\n```\n\nAs we learned in lecture, the estimates of $\\hat{B}$ from least squares and maximum likelihood are equivalent. And indeed, we see the same estimates produced from `lm()` and `optim()`. Also if you look at `Residual standard error` in the `lm()` output, you see the equivalent estimate for $\\hat{\\sigma}$ compared to the `optim()` output. \n\n## Hypothesis-testing for maximum likelihood\n\nAs explained in lecture, we will use the likelihood ratio test to test:\n\n$$H_0: \\beta_i = 0$$\n$$H_A: \\beta_i \\ne 0$$\nIn the least squares framework, we used a $t$-test. But, for maximum likelihood, we are going to base our test on the *likelihood* of a model that does or does not include the slope, similar to the $F$-test we learned before. \n\nFor the case of simple linear regression, we're testing whether there is a significant difference between these models:\n$$H_0: y_i = \\beta_0 + \\epsilon_i$$\n$$H_A: y_i = \\beta_0 + \\beta_1 x_i + \\epsilon_i$$\nNotice that in $H_0$, the slope $\\beta_1$ is assumed to be zero.  \n\n### Likelihood ratio and the $\\chi^2$ test\n\nOur goal is to understand if the likelihood of the null model, $P(Y | \\beta_0, \\sigma^2)$, is sufficiently low compared to the likelihood of the full model, $P(Y | \\beta_0, \\beta_1, x, \\sigma^2)$, that we can reliably reject the null hypothesis.\n\nWe therefore construct a ratio of the likelihoods of the full and null model, very similar to the $F$-test framework. The log-likelihood ratio ($LHR$) becomes our test statistic:\n$$LHR_{\\text{test}} = -2 ln \\left(\\frac{LH_{\\text{null}}}{LH_{\\text{full}}} \\right)$$\n\nThen, folks smarter than I have done the math to prove that this test statistic is equivalent to a $\\chi^2$ test statistic, such that:\n\n$$LHR_{\\text{test}} \\sim  \\chi^2_k$$\n\nwhere $\\chi^2_k$ is a $\\chi^2$ probability distribution with $k$ degrees of freedom. $k$ is equal to $p_{\\text{full}} - p_{\\text{null}}$, where $p$ is the number of model coefficients. In the case of simple linear regression, where we are removing just one model coefficient from the full model (i.e., set slope equal to zero), then $k = 2-1 = 1$.\n\nFinally, we can determine $P(\\chi^2 > LHR_{\\text{test}})$, which gives us our $p$-value. This statistical test is known as the \"likelihood ratio test,\" and it is equivalently referred to as the \"$\\chi^2$\" test, which we'll see in the code below. \n\n### Manual calculation of the likelihood ratio test\n\nTo begin, we need to use maximum likelihood to estimate the likelihood of the \"null\" model. We need to adjust our function that will be used by `optim()` to only include two parameters: the intercept, and the residual standard deviation. \n\n```{r}\n# Need a null model:\nnll_null = function(p, data_df){\n    beta0=p[1]\n    sigma=p[2]\n    \n    mu = beta0\n    \n    nll = -sum(dnorm(data_df$y, mean=mu, sd=sigma, log = TRUE))\n    return(nll)\n}\n\nm_nll_null = \n    optim(\n        par = c(0.1,0.1),\n        fn = nll_null,\n        data_df = my_df,\n        method = \"L-BFGS-B\",\n        lower=c(-5,0.001),\n        upper=c(5,5)\n    )\npar_tab_nll_null = rbind(m_nll_null$par)\ncolnames(par_tab_nll_null) = c(\"int\", \"sigma\")\npar_tab_nll_null\n\nplot(my_df$y ~ my_df$x, pch = 19,\n     xlab = \"x\", ylab = \"y\")\nabline(coef = m_nll$par[1:2], col = \"red\", lty = 1)\nabline(h = m_nll_null$par[1], col = \"red\", lty = 2)\n```\n\nThe flat dashed line represents the null (intercept-only) model. Now, we calculate the likelihood ratio test statistic, and compare to the $\\chi^2$ probability distribution to determine our $p$-value of the test. Note that within the `optim()` function's output list, there is a numeric object called `value`. This `value` is the negative log-likelihood of the model with the estimated coefficients. We can use this to calculate our test statistic.\n\n```{r}\n# use exp() to convert the negative log likelihood to \n# raw probability scale\nlog_lh_full = -m_nll$value\nlog_lh_null = -m_nll_null$value\n\nlh_full = exp(log_lh_full)\nlh_null = exp(log_lh_null)\n\n# Now calculate LHR\nlhr = -2 * log(lh_null / lh_full)\nlhr\n\n# Of course, using rules of natural logs, this is equivalent:\n-2 * (log_lh_null - log_lh_full)\n```\n\nNow that we have our value of $LHR_{\\text{test}}$, we use the $\\chi^2$-distribution to find $P(\\chi^2 > LHR_{\\text{test}})$, which is the $p$-value of the test.\n\n```{r}\n# How many parameters being \"removed\" (i.e., set to zero) in test:\ndf_chi = 2 - 1\n\n# Prob null is true\np_val = 1 - pchisq(lhr, df = df_chi)\np_val\n```\nBased on this low $p$-value, we would say there is sufficient evidence to reject the null hypothesis and that the slope $\\beta_1$ is significantly different than zero. \n\nWe can compare this outcome to a built-in `R` function called `drop1()`. \n\n```{r}\ndrop1(m_ols, test = \"Chisq\")\n```\n\nIn the function, we specified `Chisq` test, which implements the $\\chi^2$ test using the likelihood ratio. What we see in this summary output is `Pr(>Chi)` which is equivalent to our manually computed value of $P(\\chi^2 > LHR_{\\text{test}})$. This output from `drop1()` does not provide a whole lot of detail, but if you look at the `help()`, it says that if you specify `test = \"Chisq\"`, it conducts a likelihood-ratio test. It doesn't specifically output the likelihood ratio, but we can see the $p$-value is equivalent to our manual calculation above. \n\n## Gradient descent algorithm\n\nHow does the `optim()` function work? There are various optimization algorithms that can be implemented by `optim()` that are specified by the user in the `method` option. Several of these are gradient-based algorithms, which is a family of algorithms that are very common in engineering problems (e.g., optimal control of drones) and machine learning (e.g., neural networks, reinforcement learning). These algorithms generally minimize an \"objective function\": $\\min_{{x\\in {\\mathbb  R}^{n}}}\\;f(x)$. \n\nA gradient descent algorithm is the most common algorithm for minimizing a function. There are many varieties of these algorithms that employ various \"tricks\" to make the algorithms more efficient (e.g., find the solution in a smaller number of iterations) or more reliable. In lecture we outlined the foundational gradient descent algorithm, upon which many more advanced algorithms are based. For a function $f(x)$, find the value of $x$ that solves the problem: $\\min _{{x\\in {\\mathbb  R}^{n}}}\\;f(x)$\n\n1. Choose a starting value of $x$\n2. Evaluate $\\nabla f(x)$. With $h=10^{-4}$:\n$$\\text{grad} = \\frac{f(x+h) - f(x)}{h}$$\n3. Set the search direction as $\\text{direct} = -\\nabla f(x)$\n4. Set the step size as a fraction of $\\nabla f(x)$: $\\text{alpha} = 0.005$\n5. Update $x$ for next iteration: $$x = x + \\text{alpha}* \\text{direct}$$\n6. Repeat Steps 2-5 until $\\nabla f(x) \\approx 0$ (i.e., $||\\text{grad}|| \\le 10^{-4}$)\n\nLet's implement this algorithm for the maximum likelihood solution of simple linear regression, using the data set above. To make this easier, we're going to assume that we know the intercept and the residual standard deviation perfectly, so we are only trying to estimate the slope. See [Footnotes @sec-grad-multi] for the case in which we estimate all three model parameters simultaneously using gradient descent. \n\n```{r}\n# Set up some storage arrays:\nslope_guess = NULL\nnll_guess = NULL\n\n# initial guess\nslope = 0.1\n\n# set h for approx of gradient\nh = 1e-4\n\n# set step size\nalpha = 0.005\n\n# Set gradient to arbitrary high number\n## This makes the while() loop work\ngrad = 100\n\n# initialize counter\ni = 1\n\n# While gradient is not yet \\approx zero\nwhile (norm(grad, \"2\") > 10^-4) {\n    \n    # Store the current value of slope:\n    slope_guess[i] = slope\n    \n    #############\n    # Approximate the gradient of the nll\n    #############\n    ## Adjust the slope by a small number, h\n    slope_adj = slope + h\n    ## Calculate f(slope)\n    f_slope = neg_log_lik(p = c(beta0, slope, sigma), \n                          data_df = my_df)\n    ## Store the current nll\n    nll_guess[i] = f_slope\n    ## Calculate f(slope + h)\n    f_slope_adj = neg_log_lik(p = c(beta0, slope_adj, sigma), \n                              data_df = my_df)\n    ## Calculate gradient\n    grad = (f_slope_adj - f_slope) / h\n    \n    # search direction\n    direct = -grad\n    \n    # update slope\n    slope = slope + alpha * direct\n    \n    # counter for x\n    i = i + 1\n}\n\n# Output the optimal slope and associated nll\nn_iter = i-1\n\ngrad_descent_tab = cbind(slope_guess[n_iter], nll_guess[n_iter])\ncolnames(grad_descent_tab) = c(\"slope\", \"neg_log_lik\")\n\n# Compare to optim() outpu\noptim_nll_tab = cbind(m_nll$par[2], m_nll$value)\ncolnames(optim_nll_tab) = c(\"slope\", \"neg_log_lik\")\n\nprint(\"Gradient Descent:\");grad_descent_tab\nprint(\"optim() output:\");optim_nll_tab\n```\nNote that the estimates are not exactly the same, especially because when we used `optim()` we were estimating all three parameters simultaneously: intercept, slope, residual standard error.\n\nNow, let's visualize the gradient descent.\n\n```{r}\nplot(nll_guess ~ slope_guess, \n     pch = 19, type = \"b\", \n     ylab = \"Neg. Log. Likelihood\",\n     xlab = expression(hat(beta)[1]),\n     xlim = c(0.1, 0.6), ylim = c(15, 40))\n```\n\n\n## Footnotes \n\n### Hessian matrix {#sec-hessian}\n\nThe `optim()` function provides point estimates for the maximum likelihood-derived model coefficients. Just like in least squares regression, however, we want to quantify the uncertainty in these estimates. We therefore want the standard error in the model coefficient estimates. \n\nIn the case of least squares, we showed how we can calculate a variance-covariance matrix for the model coefficients, and then the square-root of the diagonal of this matrix equals the standard error. For maximum likelihood we can estimate this same variance-covariance matrix, but it comes from a different matrix called the Hessian. We do not need to go into detail, but the Hessian is the matrix of second derivatives of the likelihood with respect to the parameters (I will not ask you to recall this information). Then the variance-covariance matrix of the estimated model coefficients is calculated as the inverse of the Hessian matrix that corresponds to the negative log-likelihood. If the Hessian matrix of the negative log-likelihood is $H$, then\n$$SE(\\hat{\\beta_i}) = \\sqrt{\\text{diag}\\left( H^{-1}\\right)_i}$$\nI understand that's complicated, but it's easy enough to extract these values computationally from `optim()` output, assuming you use the option `hessian = TRUE`. \n```{r}\n# Extract the Hessian from the optim() output\nhessian = m_nll$hessian\n# Calculate the var-cov matrix from the inverse Hessian\n# Remember solve(X) gives X^-1\nparams_varcov = solve(hessian)\n# Then extract the diagonal and take the square root\n# This gives a vector of SE(\\param_i)\nse_params = sqrt(diag(params_varcov))\nparams_tab = cbind(m_nll$par, se_params)\ncolnames(params_tab) = c(\"Estimate\", \"Std. Error\")\nrownames(params_tab) = c(\"Intercept\", \"slope\", \"sigma\")\nparams_tab\n\n# Same as OLS? \nm_ols_summary$coefficients[c(1:2), 1:2] # Pretty close!\n```\nWe can see that the standard errors for the maximum likelihood estimators are the same as the OLS estimators. \n\n### `optim()` using least squares {#sec-least-sq}\n\nRemember that `optim()` is not specific to maximum likelihood, but rather it implements one of several optional minimization algorithms. Therefore, we can use it to minimize any quantity. To emphasize this point, remember that in least squares regression, we are finding the values of the model coefficients $\\hat{B}$ that minimize the sum of squared errors, $\\sum_i^n \\epsilon_i^2 = \\epsilon^T\\epsilon$. Let's minimize this quantity using `optim()`. \n\n```{r}\n### LEAST SQUARES MINIMIZATION\n\n# We need a function to calculate the sum of squared errors:\nleast_sq = function(p, data_df){\n    beta0=p[1]\n    beta1=p[2]\n    y = data_df$y\n    n = length(y)\n    \n    expected_y = beta0 + beta1*data_df$x\n    sse = 0\n    for(i in 1:n){\n        epsilon_i = y[i] - expected_y[i]\n        sse = sse + (epsilon_i)^2\n    }\n    \n    return(sse)\n}\n\n### OPTIMIZE LEAST SQUARES\nfit_least_sq = \n    optim(\n        par = c(0,0),\n        fn = least_sq,\n        data_df = my_df,\n        method = \"L-BFGS-B\",\n        lower=c(-5,-5),\n        upper=c(5,5),\n        hessian = TRUE\n    )\n# Create a table of estimates:\npar_tab_least_sq = rbind(fit_least_sq$par)\ncolnames(par_tab_least_sq) = c(\"int\", \"slope\")\npar_tab_least_sq\n\n# Compare to original OLS estimates:\ncoef(m_ols)\n```\n\nYou could also use the Hessian output to calculate the standard errors of the model coefficients, but I will leave that up to you.\n\n### Gradient descent, multiple parameters {#sec-grad-multi}\n\nNow let's suppose we want to estimate all of our model parameters (intercept, slope, residual standard deviation) simultaneously using gradient descent. Recall from lecture that we need to estimate three components of the gradient (the partial derivates of the function with respect to each model parameter).\n\n```{r}\n# How many params to estimate?\nn_param = 3\n\n# Set up some storage arrays:\n## Guess that the number of iterations will be 100 or less...\nparam_guess = array(0, dim=c(100,n_param))\nnll_guess = vector(\"numeric\", length = 100)\n\n# initial guesses\nparam = vector(\"numeric\", length = n_param)\nparam[1] = 0.0 # intercept\nparam[2] = 1.0\nparam[3] = 2.5\n\n# set h for approx of gradient\nh = 1e-4\n\n# set step size\nalpha = 0.005\n\n# Set gradient components to arbitrary high numbers\n## This makes the while() loop work\ngrad = rep(100, times = n_param)\n\n# initialize counter\ni = 1\n\n# While gradient is not yet \\approx zero\nwhile (norm(grad, \"2\") > 10^-4) {\n    \n    # Store the current value of slope:\n    param_guess[i, ] = param\n    \n    #############\n    # Approximate the gradient of the nll\n    #############\n    \n    ## Calculate nll with all current params\n    f_x = neg_log_lik(p = param, \n                          data_df = my_df)\n    ## Store the current nll\n    nll_guess[i] = f_x\n    \n    ## One param at a time, approximate gradient component\n    ## (i.e., partial derivative)\n    for(j in 1:n_param){\n        ## Keep all but one params the same\n        param_adj = NULL\n        param_adj = param\n        param_adj[j] = param[j] + h\n        \n        f_x_adj = neg_log_lik(p = param_adj, \n                              data_df = my_df)\n        ## Calculate gradient component\n        grad[j] = (f_x_adj - f_x) / h\n    }\n    \n    # search direction\n    ## Note that 'direct' is an array of size n_param\n    direct = -grad\n    \n    # update params\n    for(j in 1:n_param){\n        param[j] = param[j] + alpha * direct[j]\n    }\n    \n    # counter for x\n    i = i + 1\n}\n\n# Output the optimal slope and associated nll\nn_iter = i-1\n\ngrad_descent_tab = cbind(rbind(param_guess[n_iter,]), \n                         nll_guess[n_iter])\ncolnames(grad_descent_tab) = \n    c(\"int\", \"slope\", \"sigma\", \"neg_log_lik\")\n\n# Compare to optim() output\noptim_nll_tab = cbind(rbind(m_nll$par), \n                      m_nll$value)\ncolnames(optim_nll_tab) = colnames(grad_descent_tab)\n\nprint(\"Gradient Descent:\");grad_descent_tab\nprint(\"optim() output:\");optim_nll_tab\n```\n\nNow, plot the gradient descent:\n\n```{r}\npar(mfrow=c(1,3))\nplot(nll_guess[1:n_iter]~param_guess[1:n_iter, 1], \n     pch=19, type = \"b\", \n     col = \"blue\",\n     ylab = \"Neg. Log Likelihood\", \n     xlab = expression(\"Intercept, \"~beta[0]))\nplot(nll_guess[1:n_iter]~param_guess[1:n_iter, 2],\n     pch=19, type = \"b\", \n     col = \"orange\",\n     ylab = \"Neg. Log Likelihood\", \n     xlab = expression(\"Slope, \"~beta[1]))\nplot(nll_guess[1:n_iter]~param_guess[1:n_iter, 3], \n     pch=19, type = \"b\", \n     col = \"red\",\n     ylab = \"Neg. Log Likelihood\", \n     xlab = expression(\"Residual Std.Dev., \"~sigma))\n\n```\nWe can see for the intercept, our first guess was too low, so we descended the gradient by addition (i.e., search direction was positive), whereas for the slope and the residual standard deviation, our first guess was too large, so we descended the gradients by subtraction (i.e., search direction was negative).\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":{"toggle":true},"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"printing","output-file":"max-lik.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.335","crossref":{"appendix-delim":":"},"bibliography":["references.bib"],"theme":"cosmo","smooth-scroll":true,"code-block-bg":true},"extensions":{"book":{"multiFile":true}}}}}